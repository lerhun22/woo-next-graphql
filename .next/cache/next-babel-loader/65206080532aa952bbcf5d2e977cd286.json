{"ast":null,"code":"/** @format */\nimport { v4 } from \"uuid\";\n/**\n * Extracts and returns float value from a string.\n *\n * @param {string} string String\n * @return {any}\n */\n\nexport const getFloatVal = string => {\n  let floatValue = string.match(/[+-]?\\d+(\\.\\d+)?/g)[0];\n  return null !== floatValue ? parseFloat(parseFloat(floatValue).toFixed(2)) : \"\";\n};\n/**\n * Add first product.\n *\n * @param {Object} product Product\n * @return {{totalProductsCount: number, totalProductsPrice: any, products: Array}}\n */\n\nexport const addFirstProduct = product => {\n  let productPrice = getFloatVal(product.price);\n  let newCart = {\n    products: [],\n    totalProductsCount: 1,\n    totalProductsPrice: productPrice\n  };\n  const newProduct = createNewProduct(product, productPrice, 1);\n  newCart.products.push(newProduct);\n  localStorage.setItem(\"woo-next-cart\", JSON.stringify(newCart));\n  return newCart;\n};\n/**\n * Create a new product object.\n *\n * @param {Object} product Product\n * @param {Integer} productPrice Product Price\n * @param {Integer} qty Quantity\n * @return {{image: *, productId: *, totalPrice: number, price: *, qty: *, name: *}}\n */\n\nexport const createNewProduct = (product, productPrice, qty) => {\n  return {\n    productId: product.productId,\n    image: product.image,\n    name: product.name,\n    price: productPrice,\n    qty,\n    totalPrice: parseFloat((productPrice * qty).toFixed(2))\n  };\n};\n/**\n * Updates the existing cart with new item.\n *\n * @param {Object} existingCart Existing Cart.\n * @param {Object} product Product.\n * @param {Integer} qtyToBeAdded Quantity.\n * @param {Integer} newQty New Qty to be updated.\n * @return {{totalProductsCount: *, totalProductsPrice: *, products: *}}\n */\n\nexport const updateCartBIS = (existingCart, product, qtyToBeAdded, newQty = false) => {\n  const updatedProducts = getUpdatedProducts(existingCart.products, product, qtyToBeAdded, newQty);\n\n  const addPrice = (total, item) => {\n    total.totalPrice += item.totalPrice;\n    total.qty += item.qty;\n    return total;\n  }; // Loop through the updated product array and add the totalPrice of each item to get the totalPrice\n\n\n  let total = updatedProducts.reduce(addPrice, {\n    totalPrice: 0,\n    qty: 0\n  });\n  const updatedCart = {\n    products: updatedProducts,\n    totalProductsCount: parseInt(total.qty),\n    totalProductsPrice: parseFloat(total.totalPrice)\n  };\n  localStorage.setItem(\"woo-next-cart\", JSON.stringify(updatedCart));\n  return updatedCart;\n};\n/**\n * Get updated products array\n * Update the product if it exists else,\n * add the new product to existing cart,\n *\n * @param {Object} existingProductsInCart Existing product in cart\n * @param {Object} product Product\n * @param {Integer} qtyToBeAdded Quantity\n * @param {Integer} newQty New qty of the product (optional)\n * @return {*[]}\n */\n\nexport const getUpdatedProducts = (existingProductsInCart, product, qtyToBeAdded, newQty = false) => {\n  // Check if the product already exits in the cart.\n  const productExitsIndex = isProductInCart(existingProductsInCart, product.productId); // If product exits ( index of that product found in the array ), update the product quantity and totalPrice\n\n  if (-1 < productExitsIndex) {\n    let updatedProducts = existingProductsInCart;\n    let updatedProduct = updatedProducts[productExitsIndex]; // If have new qty of the product available, set that else add the qtyToBeAdded\n\n    updatedProduct.qty = newQty ? parseInt(newQty) : parseInt(updatedProduct.qty + qtyToBeAdded);\n    updatedProduct.totalPrice = parseFloat((updatedProduct.price * updatedProduct.qty).toFixed(2));\n    return updatedProducts;\n  } else {\n    // If product not found push the new product to the existing product array.\n    let productPrice = getFloatVal(product.price);\n    const newProduct = createNewProduct(product, productPrice, qtyToBeAdded);\n    existingProductsInCart.push(newProduct);\n    return existingProductsInCart;\n  }\n};\n/**\n * Returns index of the product if it exists.\n *\n * @param {Object} existingProductsInCart Existing Products.\n * @param {Integer} productId Product id.\n * @return {number | *} Index Returns -1 if product does not exist in the array, index number otherwise\n */\n\nconst isProductInCart = (existingProductsInCart, productId) => {\n  const returnItemThatExits = (item, index) => {\n    if (productId === item.productId) {\n      return item;\n    }\n  }; // This new array will only contain the product which is matched.\n\n\n  const newArray = existingProductsInCart.filter(returnItemThatExits);\n  return existingProductsInCart.indexOf(newArray[0]);\n};\n/**\n * Remove Item from the cart.\n *\n * @param {Integer} productId Product Id.\n * @return {any | string} Updated cart\n */\n\n\nexport const removeItemFromCart = productId => {\n  let existingCart = localStorage.getItem(\"woo-next-cart\");\n  existingCart = JSON.parse(existingCart); // If there is only one item in the cart, delete the cart.\n\n  if (1 === existingCart.products.length) {\n    localStorage.removeItem(\"woo-next-cart\");\n    return null;\n  } // Check if the product already exits in the cart.\n\n\n  const productExitsIndex = isProductInCart(existingCart.products, productId); // If product to be removed exits\n\n  if (-1 < productExitsIndex) {\n    const productTobeRemoved = existingCart.products[productExitsIndex];\n    const qtyToBeRemovedFromTotal = productTobeRemoved.qty;\n    const priceToBeDeductedFromTotal = productTobeRemoved.totalPrice; // Remove that product from the array and update the total price and total quantity of the cart\n\n    let updatedCart = existingCart;\n    updatedCart.products.splice(productExitsIndex, 1);\n    updatedCart.totalProductsCount = updatedCart.totalProductsCount - qtyToBeRemovedFromTotal;\n    updatedCart.totalProductsPrice = updatedCart.totalProductsPrice - priceToBeDeductedFromTotal;\n    localStorage.setItem(\"woo-next-cart\", JSON.stringify(updatedCart));\n    return updatedCart;\n  } else {\n    return existingCart;\n  }\n};\n/**\n * Returns cart data in the required format.\n * @param {String} data Cart data\n */\n\nexport const getFormattedCart = data => {\n  let formattedCart = null;\n\n  if (undefined === data || !data.cart.contents.nodes.length) {\n    return formattedCart;\n  }\n\n  const givenProducts = data.cart.contents.nodes; // Create an empty object.\n\n  formattedCart = {};\n  formattedCart.products = [];\n  let totalProductsCount = 0;\n\n  for (let i = 0; i < givenProducts.length; i++) {\n    const givenProduct = givenProducts[i].product;\n    const product = {};\n    const total = getFloatVal(givenProducts[i].total);\n    product.productId = givenProduct.productId;\n    product.cartKey = givenProducts[i].key;\n    product.name = givenProduct.name;\n    product.qty = givenProducts[i].quantity;\n    product.price = total / product.qty;\n    product.totalPrice = givenProducts[i].total;\n    product.image = {\n      sourceUrl: givenProduct.image.sourceUrl,\n      srcSet: givenProduct.image.srcSet,\n      title: givenProduct.image.title\n    };\n    totalProductsCount += givenProducts[i].quantity; // Push each item into the products array.\n\n    formattedCart.products.push(product);\n  }\n\n  formattedCart.totalProductsCount = totalProductsCount;\n  formattedCart.totalProductsPrice = data.cart.total;\n  return formattedCart;\n};\nexport const createCheckoutData = order => {\n  const checkoutData = {\n    clientMutationId: v4(),\n    billing: {\n      firstName: order.firstName,\n      lastName: order.lastName,\n      address1: order.address1,\n      address2: order.address2,\n      city: order.city,\n      country: order.country,\n      state: order.state,\n      postcode: order.postcode,\n      email: order.email,\n      phone: order.phone,\n      company: order.company\n    },\n    shipping: {\n      firstName: order.firstName,\n      lastName: order.lastName,\n      address1: order.address1,\n      address2: order.address2,\n      city: order.city,\n      country: order.country,\n      state: order.state,\n      postcode: order.postcode,\n      email: order.email,\n      phone: order.phone,\n      company: order.company\n    },\n    shipToDifferentAddress: false,\n    paymentMethod: order.paymentMethod,\n    isPaid: false,\n    transactionId: \"hjkhjkhsdsdiui\"\n  };\n  return checkoutData;\n};\n/**\n * Get the updated items in the below format required for mutation input.\n *\n * [\n * { \"key\": \"33e75ff09dd601bbe6dd51039152189\", \"quantity\": 1 },\n * { \"key\": \"02e74f10e0327ad868d38f2b4fdd6f0\", \"quantity\": 1 },\n * ]\n *\n * Creates an array in above format with the newQty (updated Qty ).\n *\n */\n\nexport const getUpdatedItems = (products, newQty, cartKey) => {\n  // Create an empty array.\n  const updatedItems = []; // Loop through the product array.\n\n  products.map(cartItem => {\n    // If you find the cart key of the product user is trying to update, push the key and new qty.\n    if (cartItem.cartKey === cartKey) {\n      updatedItems.push({\n        key: cartItem.cartKey,\n        quantity: parseInt(newQty)\n      }); // Otherwise just push the existing qty without updating.\n    } else {\n      updatedItems.push({\n        key: cartItem.cartKey,\n        quantity: cartItem.qty\n      });\n    }\n  }); // Return the updatedItems array with new Qtys.\n\n  return updatedItems;\n};","map":{"version":3,"sources":["/Users/didierflury/Documents/Realiser/pweb/woo-next/functions.js"],"names":["v4","getFloatVal","string","floatValue","match","parseFloat","toFixed","addFirstProduct","product","productPrice","price","newCart","products","totalProductsCount","totalProductsPrice","newProduct","createNewProduct","push","localStorage","setItem","JSON","stringify","qty","productId","image","name","totalPrice","updateCartBIS","existingCart","qtyToBeAdded","newQty","updatedProducts","getUpdatedProducts","addPrice","total","item","reduce","updatedCart","parseInt","existingProductsInCart","productExitsIndex","isProductInCart","updatedProduct","returnItemThatExits","index","newArray","filter","indexOf","removeItemFromCart","getItem","parse","length","removeItem","productTobeRemoved","qtyToBeRemovedFromTotal","priceToBeDeductedFromTotal","splice","getFormattedCart","data","formattedCart","undefined","cart","contents","nodes","givenProducts","i","givenProduct","cartKey","key","quantity","sourceUrl","srcSet","title","createCheckoutData","order","checkoutData","clientMutationId","billing","firstName","lastName","address1","address2","city","country","state","postcode","email","phone","company","shipping","shipToDifferentAddress","paymentMethod","isPaid","transactionId","getUpdatedItems","updatedItems","map","cartItem"],"mappings":"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","sourcesContent":["/** @format */\n\nimport { v4 } from \"uuid\";\n\n/**\n * Extracts and returns float value from a string.\n *\n * @param {string} string String\n * @return {any}\n */\nexport const getFloatVal = (string) => {\n\tlet floatValue = string.match(/[+-]?\\d+(\\.\\d+)?/g)[0];\n\treturn null !== floatValue\n\t\t? parseFloat(parseFloat(floatValue).toFixed(2))\n\t\t: \"\";\n};\n\n/**\n * Add first product.\n *\n * @param {Object} product Product\n * @return {{totalProductsCount: number, totalProductsPrice: any, products: Array}}\n */\nexport const addFirstProduct = (product) => {\n\tlet productPrice = getFloatVal(product.price);\n\n\tlet newCart = {\n\t\tproducts: [],\n\t\ttotalProductsCount: 1,\n\t\ttotalProductsPrice: productPrice,\n\t};\n\n\tconst newProduct = createNewProduct(product, productPrice, 1);\n\tnewCart.products.push(newProduct);\n\n\tlocalStorage.setItem(\"woo-next-cart\", JSON.stringify(newCart));\n\n\treturn newCart;\n};\n\n/**\n * Create a new product object.\n *\n * @param {Object} product Product\n * @param {Integer} productPrice Product Price\n * @param {Integer} qty Quantity\n * @return {{image: *, productId: *, totalPrice: number, price: *, qty: *, name: *}}\n */\nexport const createNewProduct = (product, productPrice, qty) => {\n\treturn {\n\t\tproductId: product.productId,\n\t\timage: product.image,\n\t\tname: product.name,\n\t\tprice: productPrice,\n\t\tqty,\n\t\ttotalPrice: parseFloat((productPrice * qty).toFixed(2)),\n\t};\n};\n\n/**\n * Updates the existing cart with new item.\n *\n * @param {Object} existingCart Existing Cart.\n * @param {Object} product Product.\n * @param {Integer} qtyToBeAdded Quantity.\n * @param {Integer} newQty New Qty to be updated.\n * @return {{totalProductsCount: *, totalProductsPrice: *, products: *}}\n */\nexport const updateCartBIS = (\n\texistingCart,\n\tproduct,\n\tqtyToBeAdded,\n\tnewQty = false\n) => {\n\tconst updatedProducts = getUpdatedProducts(\n\t\texistingCart.products,\n\t\tproduct,\n\t\tqtyToBeAdded,\n\t\tnewQty\n\t);\n\n\tconst addPrice = (total, item) => {\n\t\ttotal.totalPrice += item.totalPrice;\n\t\ttotal.qty += item.qty;\n\n\t\treturn total;\n\t};\n\n\t// Loop through the updated product array and add the totalPrice of each item to get the totalPrice\n\tlet total = updatedProducts.reduce(addPrice, { totalPrice: 0, qty: 0 });\n\n\tconst updatedCart = {\n\t\tproducts: updatedProducts,\n\t\ttotalProductsCount: parseInt(total.qty),\n\t\ttotalProductsPrice: parseFloat(total.totalPrice),\n\t};\n\n\tlocalStorage.setItem(\"woo-next-cart\", JSON.stringify(updatedCart));\n\n\treturn updatedCart;\n};\n\n/**\n * Get updated products array\n * Update the product if it exists else,\n * add the new product to existing cart,\n *\n * @param {Object} existingProductsInCart Existing product in cart\n * @param {Object} product Product\n * @param {Integer} qtyToBeAdded Quantity\n * @param {Integer} newQty New qty of the product (optional)\n * @return {*[]}\n */\nexport const getUpdatedProducts = (\n\texistingProductsInCart,\n\tproduct,\n\tqtyToBeAdded,\n\tnewQty = false\n) => {\n\t// Check if the product already exits in the cart.\n\tconst productExitsIndex = isProductInCart(\n\t\texistingProductsInCart,\n\t\tproduct.productId\n\t);\n\n\t// If product exits ( index of that product found in the array ), update the product quantity and totalPrice\n\tif (-1 < productExitsIndex) {\n\t\tlet updatedProducts = existingProductsInCart;\n\t\tlet updatedProduct = updatedProducts[productExitsIndex];\n\n\t\t// If have new qty of the product available, set that else add the qtyToBeAdded\n\t\tupdatedProduct.qty = newQty\n\t\t\t? parseInt(newQty)\n\t\t\t: parseInt(updatedProduct.qty + qtyToBeAdded);\n\t\tupdatedProduct.totalPrice = parseFloat(\n\t\t\t(updatedProduct.price * updatedProduct.qty).toFixed(2)\n\t\t);\n\n\t\treturn updatedProducts;\n\t} else {\n\t\t// If product not found push the new product to the existing product array.\n\t\tlet productPrice = getFloatVal(product.price);\n\t\tconst newProduct = createNewProduct(product, productPrice, qtyToBeAdded);\n\t\texistingProductsInCart.push(newProduct);\n\n\t\treturn existingProductsInCart;\n\t}\n};\n\n/**\n * Returns index of the product if it exists.\n *\n * @param {Object} existingProductsInCart Existing Products.\n * @param {Integer} productId Product id.\n * @return {number | *} Index Returns -1 if product does not exist in the array, index number otherwise\n */\nconst isProductInCart = (existingProductsInCart, productId) => {\n\tconst returnItemThatExits = (item, index) => {\n\t\tif (productId === item.productId) {\n\t\t\treturn item;\n\t\t}\n\t};\n\n\t// This new array will only contain the product which is matched.\n\tconst newArray = existingProductsInCart.filter(returnItemThatExits);\n\n\treturn existingProductsInCart.indexOf(newArray[0]);\n};\n\n/**\n * Remove Item from the cart.\n *\n * @param {Integer} productId Product Id.\n * @return {any | string} Updated cart\n */\nexport const removeItemFromCart = (productId) => {\n\tlet existingCart = localStorage.getItem(\"woo-next-cart\");\n\texistingCart = JSON.parse(existingCart);\n\n\t// If there is only one item in the cart, delete the cart.\n\tif (1 === existingCart.products.length) {\n\t\tlocalStorage.removeItem(\"woo-next-cart\");\n\t\treturn null;\n\t}\n\n\t// Check if the product already exits in the cart.\n\tconst productExitsIndex = isProductInCart(existingCart.products, productId);\n\n\t// If product to be removed exits\n\tif (-1 < productExitsIndex) {\n\t\tconst productTobeRemoved = existingCart.products[productExitsIndex];\n\t\tconst qtyToBeRemovedFromTotal = productTobeRemoved.qty;\n\t\tconst priceToBeDeductedFromTotal = productTobeRemoved.totalPrice;\n\n\t\t// Remove that product from the array and update the total price and total quantity of the cart\n\t\tlet updatedCart = existingCart;\n\t\tupdatedCart.products.splice(productExitsIndex, 1);\n\t\tupdatedCart.totalProductsCount =\n\t\t\tupdatedCart.totalProductsCount - qtyToBeRemovedFromTotal;\n\t\tupdatedCart.totalProductsPrice =\n\t\t\tupdatedCart.totalProductsPrice - priceToBeDeductedFromTotal;\n\n\t\tlocalStorage.setItem(\"woo-next-cart\", JSON.stringify(updatedCart));\n\t\treturn updatedCart;\n\t} else {\n\t\treturn existingCart;\n\t}\n};\n\n/**\n * Returns cart data in the required format.\n * @param {String} data Cart data\n */\nexport const getFormattedCart = (data) => {\n\tlet formattedCart = null;\n\n\tif (undefined === data || !data.cart.contents.nodes.length) {\n\t\treturn formattedCart;\n\t}\n\n\tconst givenProducts = data.cart.contents.nodes;\n\n\t// Create an empty object.\n\tformattedCart = {};\n\tformattedCart.products = [];\n\tlet totalProductsCount = 0;\n\n\tfor (let i = 0; i < givenProducts.length; i++) {\n\t\tconst givenProduct = givenProducts[i].product;\n\t\tconst product = {};\n\t\tconst total = getFloatVal(givenProducts[i].total);\n\n\t\tproduct.productId = givenProduct.productId;\n\t\tproduct.cartKey = givenProducts[i].key;\n\t\tproduct.name = givenProduct.name;\n\t\tproduct.qty = givenProducts[i].quantity;\n\t\tproduct.price = total / product.qty;\n\t\tproduct.totalPrice = givenProducts[i].total;\n\t\tproduct.image = {\n\t\t\tsourceUrl: givenProduct.image.sourceUrl,\n\t\t\tsrcSet: givenProduct.image.srcSet,\n\t\t\ttitle: givenProduct.image.title,\n\t\t};\n\n\t\ttotalProductsCount += givenProducts[i].quantity;\n\n\t\t// Push each item into the products array.\n\t\tformattedCart.products.push(product);\n\t}\n\n\tformattedCart.totalProductsCount = totalProductsCount;\n\tformattedCart.totalProductsPrice = data.cart.total;\n\n\treturn formattedCart;\n};\n\nexport const createCheckoutData = (order) => {\n\tconst checkoutData = {\n\t\tclientMutationId: v4(),\n\n\t\tbilling: {\n\t\t\tfirstName: order.firstName,\n\t\t\tlastName: order.lastName,\n\t\t\taddress1: order.address1,\n\t\t\taddress2: order.address2,\n\t\t\tcity: order.city,\n\t\t\tcountry: order.country,\n\t\t\tstate: order.state,\n\t\t\tpostcode: order.postcode,\n\t\t\temail: order.email,\n\t\t\tphone: order.phone,\n\t\t\tcompany: order.company,\n\t\t},\n\t\tshipping: {\n\t\t\tfirstName: order.firstName,\n\t\t\tlastName: order.lastName,\n\t\t\taddress1: order.address1,\n\t\t\taddress2: order.address2,\n\t\t\tcity: order.city,\n\t\t\tcountry: order.country,\n\t\t\tstate: order.state,\n\t\t\tpostcode: order.postcode,\n\t\t\temail: order.email,\n\t\t\tphone: order.phone,\n\t\t\tcompany: order.company,\n\t\t},\n\t\tshipToDifferentAddress: false,\n\t\tpaymentMethod: order.paymentMethod,\n\t\tisPaid: false,\n\t\ttransactionId: \"hjkhjkhsdsdiui\",\n\t};\n\n\treturn checkoutData;\n};\n\n/**\n * Get the updated items in the below format required for mutation input.\n *\n * [\n * { \"key\": \"33e75ff09dd601bbe6dd51039152189\", \"quantity\": 1 },\n * { \"key\": \"02e74f10e0327ad868d38f2b4fdd6f0\", \"quantity\": 1 },\n * ]\n *\n * Creates an array in above format with the newQty (updated Qty ).\n *\n */\nexport const getUpdatedItems = (products, newQty, cartKey) => {\n\t// Create an empty array.\n\tconst updatedItems = [];\n\n\t// Loop through the product array.\n\tproducts.map((cartItem) => {\n\t\t// If you find the cart key of the product user is trying to update, push the key and new qty.\n\t\tif (cartItem.cartKey === cartKey) {\n\t\t\tupdatedItems.push({\n\t\t\t\tkey: cartItem.cartKey,\n\t\t\t\tquantity: parseInt(newQty),\n\t\t\t});\n\n\t\t\t// Otherwise just push the existing qty without updating.\n\t\t} else {\n\t\t\tupdatedItems.push({\n\t\t\t\tkey: cartItem.cartKey,\n\t\t\t\tquantity: cartItem.qty,\n\t\t\t});\n\t\t}\n\t});\n\n\t// Return the updatedItems array with new Qtys.\n\treturn updatedItems;\n};\n"]},"metadata":{},"sourceType":"module"}